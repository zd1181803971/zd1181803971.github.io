{"meta":{"title":"赵董の博客","subtitle":"记录学习生活中的点点滴滴","description":"能学就多学点吧","author":"ZhaoDong","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2020-04-10T09:47:46.446Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2020-04-10T09:49:18.743Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring","slug":"Spring","date":"2020-04-10T14:28:32.000Z","updated":"2020-04-10T16:51:43.110Z","comments":true,"path":"2020/04/10/Spring/","link":"","permalink":"http://yoursite.com/2020/04/10/Spring/","excerpt":"Spring","text":"Spring IOCIoC全称Inversion of Control，直译为控制反转 AOPAspect Oriented Programming, 称为面向切面编程","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SringMVC","slug":"SringMVC","date":"2020-04-10T06:26:48.000Z","updated":"2020-04-10T14:27:23.484Z","comments":true,"path":"2020/04/10/SringMVC/","link":"","permalink":"http://yoursite.com/2020/04/10/SringMVC/","excerpt":"SpringMVC入门程序","text":"SpringMVC入门程序 环境搭建 导入依赖 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 修改web.xml 1234567891011121314151617181920212223242526272829&lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; SpringMVC配置文件 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开始注释扫描--&gt; &lt;context:component-scan base-package=\"cn.dzu\"&gt;&lt;/context:component-scan&gt; &lt;!--视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启SpringMVC框架注释的支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; To be continued…","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Mybatis","slug":"Mybatis","date":"2020-04-10T04:52:42.000Z","updated":"2020-04-12T14:49:27.550Z","comments":true,"path":"2020/04/10/Mybatis/","link":"","permalink":"http://yoursite.com/2020/04/10/Mybatis/","excerpt":"Mybatis","text":"Mybatis 1.Mybatis环境说明、 jdk 8+ MySQL 5.7.19 maven-3.5.2 IDEA 2018.3.6 2.什么是MyBatis、 MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3、 3.MyBatis入门程序b站视频地址：https://www.bilibili.com/video/BV1NE411Q7Nx 导入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 主配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--mybatis主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的4个基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF8\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/dzu/mapper/CustomerMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Dao层接口方法对应的xml配置文 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dzu.dao.IUserDao\"&gt; &lt;!--配置查询所有 id是IUserDao里面的方法名称--&gt; &lt;!--mybatis的映射配置文件位置必须和dao接口的包结构相同 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 映射配置文件的操作配置（select） id 属性的取值必须是dao接口的方法名 无需再写dao的实现类 --&gt; &lt;select id=\"findAll\" resultType=\"com.dzu.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类 1234567891011121314151617181920212223public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 //SqlSessionFactoryBuilder一旦创建了SqlSessionFactory，就不再需要他了 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，默认单例模式 SqlSessionFactory factory = builder.build(in); //3.使用工厂生产一个SqlSession对象 //每次收到http请求，就可以打开一个SqlSession。所以关闭操作很重要 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 CustomerMapper csm = session.getMapper(CustomerMapper.class); //5，使用代理对象执行方法 List&lt;User&gt; users = csm.findAll(); for (User user : users) System.out.println(user); //6.释放资源 session.close(); in.close(); &#125;&#125; 4.可能出现问题说明：Maven静态资源过滤问题 ​ Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource CustomerMapper.xml 123456789101112131415161718&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 可能遇到的问题 配置文件没有注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 5.CRUD namespace namespace中的包名要和Dao/Mapper接口的包名一致！ select 查询语句 id：就是对应的namespace中的方法名； resultType： Sql语句执行的返回值！ parameterType: 参数类型 多个参数用Map 或者注解 编写接口 编写对应的mapper中的sql语句 测试 注意增删改commit的提交！！！ 标签不要匹配错 程序配置文件必须符合规范 资源路径 resource绑定mapper使用路径 6.配置解析1.核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 元素类型为 “configuration” 的内容必须匹配 “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”。 2.环境配置（environments）Mybatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，单每个SqlSessionFactory实例只能选择一种环境 Mybatis默认的事务管理器就是JDBC， 连接池 ： POOLED 3.属性（properties）我们可以通过properties属性来引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性。【db.properties】 编写一个配置文件 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisusername=rootpassword=root 在核心配置文件进行引入 12345&lt;!--引入外部配置文件 优先使用--&gt;&lt;properties resource=\"db.properties\"&gt; &lt;property name=\"u\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"p\" value=\"root\"&gt;&lt;/property&gt;&lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置的！ 4.类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 扫描实体类的包，他的默认别名就为这个类的 类名 首字母小写 12345&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;!--&lt;typeAlias type=\"com.dzu.pojo.User\" alias=\"User\"&gt;&lt;/typeAlias&gt;--&gt; &lt;package name=\"com.dzu.pojo\" &gt;&lt;/package&gt;&lt;/typeAliases&gt; 实体类少的时候 用第一种 实体类多 第二种 第一种可以DIY起名 第二种不行，如果非要改，在实体类上增加注释 12@Alias(\"user\")public class User &#123; 5.设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 6.其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） mybatis-generator-core mybatis-plus 通用mapper 7.映射器（mappers）MapperRegistry：注册绑定我们的Mapper文件 1.[推荐使用，大多数] 1234&lt;!--每一个Mapper。xml都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 2.使用class文件绑定注册 1234&lt;mappers&gt; &lt;!--&lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;--&gt; &lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 注意点 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 3.使用扫描包进行注入绑定 12345&lt;mappers&gt; &lt;!--&lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;--&gt; &lt;package name=\"com.dzu.mapper\"&gt;&lt;/package&gt;&lt;/mappers&gt; 注意点 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 练习 将数据库配置文件外部引入 实体类别名 保证UserMapper接口和UserMapper.xml保持一致，并放在同一个包下 8.生命周期和作用域生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBulider 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory 说白了就是可以想象为：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 SqlSessionFactory 的最佳作用域是应用作用域 最简单的就是使用单例模式或者静态单例模式。 SqlSession 连接到连接池的一个请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后赶紧关闭，否则资源被占用 SqlSessionFactory可以open多个SqlSession，SqlSession也能get多个Mapper 每一个Mapper，就代表一个具体的业务！ 7.解决属性名和字段名不一致的问题解决方案 起别名 123&lt;select id=\"findUserById\" resultType=\"user\" parameterType=\"int\"&gt; select id,name,pwd as password from user where id = #&#123;id&#125;;&lt;/select&gt; resultMap结果集映射 123456789101112&lt;!--结果集映射--&gt;&lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!--column数据库中的字段 property实体类中的属性--&gt; &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;result column=\"pwd\" property=\"password\"&gt;&lt;/result&gt;&lt;/resultMap&gt; &lt;select id=\"findUserById\" resultMap=\"UserMap\" parameterType=\"int\"&gt; select * from user where id = #&#123;id&#125;;&lt;/select&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们 如果这个世界总是这么简单就好了。 8.日志1.日志工厂如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手。 SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在mybatis中具体使用哪一个日志实现，在设置中设定 STDOUT_LOGGING 标准日志输出 在Mybatis核心配置文件中，配置我们的日志 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; 2.Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等； 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 导入log4j的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties文件的配置 简单使用 在要使用Log4j的类中，导入包import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(Test.class); 日志级别 123logger.info(\"info\");logger.debug(\"debug\");logger.error(\"error\"); 9.分页1.为什么要分页 减少数据的处理量 2.使用Limit分页1语法：select * from mybatis.user limit startIndex,pageSize; 使用Mybatis实现分页，核心SQL 1.接口 1List&lt;User&gt; getUserLimit(Map&lt;String,Integer&gt; map); 2.Mapper.xml 123&lt;select id=\"getUserLimit\" parameterType=\"map\" resultType=\"User\"&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;/select&gt; 3.测试 12345678910SqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);HashMap&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();map.put(\"startIndex\",0);map.put(\"pageSize\",1);List&lt;User&gt; users = mapper.getUserLimit(map);for (User user : users) &#123; System.out.println(user);&#125;sqlSession.close(); 10.使用注解开发面向接口编程； 解耦，可扩展，提高复用，分层开发 1.注解在接口上实现 12@Select(\"select * from user\")List&lt;User&gt; getUsers(); 2.需要在核心配置文件中绑定接口 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 本质：反射机制实现 底层：动态代理 关于@param()注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个类型的话，可以忽略，建议加上 我们在SQL中引用的就是我们这里的@Param()中设定的属性名 11.Mybatis执行流程Resources获取加载全局配置文件 实例化SqlsessionFactoryBuilder构造器 解析文件流XMLConfigBuilder Configuration所有的配置信息 SqlSessionFactory实例化 transactional事务管理 创建executor执行器 创建SqlSession 实现CRUD false则回滚 是否执行成功 false则回滚 提交事务 关闭 12.多对一处理测试环境搭建12345678910111213141516171819202122create table teacher( id int(10) not null, name varchar(30) default null, primary key (id)) engine=innodb default charset=utf8insert into teacher(id,name) values (1,'赵老师');create table student( id int(10) not null, name varchar(30) default null, tid int(10) default null, primary key (id), key fktid (tid), constraint fktid foreign key (tid) references teacher(id))engine=innodb default charset=utf8insert into student(id,name,tid) values (1,'小明',1);insert into student(id,name,tid) values (2,'小等',1);insert into student(id,name,tid) values (3,'小的',1);insert into student(id,name,tid) values (4,'小给',1);insert into student(id,name,tid) values (5,'小和',1); 导入lombok 新建实体类Teacher,Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件 测试查询能否成功 按照查询嵌套处理12345678910111213141516&lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from student;&lt;/select&gt;&lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"name\"&gt;&lt;/result&gt; &lt;!--复杂的属性，我们需要单独处理--&gt; &lt;!--对象： association 集合： collection --&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from teacher where id = #&#123;id&#125;;&lt;/select&gt; 按照结果嵌套处理12345678910111213&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid,s.name sname,t.id tid ,t.name tname from student s ,teacher t where s.tid = t.id ; &lt;/select&gt; &lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"sname\"&gt;&lt;/result&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"id\" column=\"tid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"tname\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 13.一对多处理比如：一个老师拥有多个学生 对于老师而言，就是一对多的关系。 搭建环境 和刚才一样 实体类 123456@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 12345678@Datapublic class Teacher &#123; private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students;&#125; 按照结果嵌套处理 12345678910111213141516171819202122&lt;!--按照结果嵌套查询--&gt;&lt;select id=\"getTeacher\" resultMap=\"TeacherStudent\"&gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=\"TeacherStudent\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"tid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"tname\"&gt;&lt;/result&gt; &lt;!--复杂的属性，我们需要单独处理--&gt; &lt;!--对象： association 集合： collection javaType 指定属性的类型！ 集合中的泛型信息 我们使用ofType获取 --&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"sname\"&gt;&lt;/result&gt; &lt;result property=\"tid\" column=\"tid\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理 12345678910111213&lt;select id=\"getTeacher2\" resultMap=\"TeacherStudent2\"&gt; select * from teacher where id =#&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=\"TeacherStudent2\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentsByTeacherID\" column=\"id\"&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"getStudentsByTeacherID\" resultType=\"Student\"&gt; select * from student where tid = #&#123;tid&#125;&lt;/select&gt; 小结 关联- association【多对一】 集合- collection javaType &amp; ofType 1.javaType 用来指定实体类中属性的类型 2.ofType 用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！ 注意点保证SQL的可读性，尽量保证通俗易懂！注意一对多和多对一中，属性名和字段的问题！如果问题不好排查错误，可以使用日志，建议Log4j 面试高频Mysql引擎innoDB底层原理索引索引优化！ 14.动态SQL什么是动态sql： 动态sql就是根据不同的条件生成不同的sql语句 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach 搭建环境1234567create table blog( id varchar(50) not null comment '博客id', title varchar(100) not null comment '博客标题', author varchar(30) not null comment '博客作者', create_time datetime not null comment '创建时间', views int(30) not null comment '浏览量')engine=innodb default charset=utf8; 创建一个基础工程 导包 编写配置文件 编写实体类 12345678@Datapublic class Blog &#123; private int id; private String title; private String author; private Date createTime; private int views;&#125; 编写实体类对应Mapper接口和Mapper.xml文件 IF123456789&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog where 1=1 &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; trim (where, set)set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 1234567891011&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 123456789101112&lt;update id=\"updateBlog\" parameterType=\"map\"&gt; update blog &lt;set&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; author =#&#123;author&#125; &lt;/if&gt; where id = #&#123;id&#125; &lt;/set&gt;&lt;/update&gt; choose (when, otherwise)123456789101112131415161718传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就 按 otherwise 里面的查找&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title != null\"&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views =#&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 所谓的动态SQL, 本只还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 SQL片段有的时候 我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 12345678&lt;sql id=\"if-title-author\"&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author =#&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 在需要使用的地方使用include标签引用即可 123456&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; 注意事项 最好基于单表来定义SQL片段 sql标签内 不要存在where标签 foreach12345678910官网：&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 123456789&lt;!--我们传递一个万能Map，里面存在一个集合--&gt;&lt;select id=\"queryBlogForeach\" resultType=\"Blog\" parameterType=\"map\"&gt; select * from blog &lt;where&gt; &lt;foreach collection=\"mid\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mybatis中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可 15.缓存Mybatis缓存 MyBatis包含- 个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效 MyBatis系统中默认定义了两级缓存: 一级缓存和二级缓存 1、默认情况下，只有一级缓存开启。(SqlSession级别的缓存, 也称为本地缓存) 2、二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 3、为了提高扩展性, MyBatis定义了缓存接口Cache.我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存：SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤 开启日志 测试再一个Session、中查询两次相同的记录 查看日志输出 12345678910111213Opening JDBC ConnectionCreated connection 238157928.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)===============User(id=1, name=zd, pwd=123)true &gt;&gt;&gt; user == user2Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@e320068]Returned connection 238157928 to pool. 缓存失效的情况 查询不同的东西 曾删改操作，可能会改变原来的数据，所以必定会刷新缓存 123456789101112131415161718192021Opening JDBC ConnectionCreated connection 32863545.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)==&gt; Preparing: update mybatis.user set name=?,pwd=? where id = ? ==&gt; Parameters: aaa(String), nnn(String), 2(Integer)&lt;== Updates: 1=================&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)false 》》》 缓存刷新 两个User不相等Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1f57539]Returned connection 32863545 to pool. 查询不同的Mapper.xml 手动清理缓存：SqlSession.clearCache(); 123456789101112131415161718Opening JDBC ConnectionCreated connection 32863545.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)=================&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)falseClosing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1f57539]Returned connection 32863545 to pool. 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个Map","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"如何搭建Hexo简单教程","slug":"我的第一篇博客文章","date":"2020-04-10T03:23:21.000Z","updated":"2020-04-10T14:16:25.646Z","comments":true,"path":"2020/04/10/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/04/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"##如何搭建Hexo 简单搭建Hexo","text":"##如何搭建Hexo 简单搭建Hexo 安装nods.js 进入cmd，npm外网太慢，用taobaonpm install -g cnpm –registry=https://registry.npm.taobao.org 安装hexocnpm install -g hexo-cli 初始化hexohexo init 启动hexo s 创建新的博客 hexo n ##将hexo发布到github 安装 gitcnpm install –save hexo-deployer-git 修改_config.yml文件 type: git repo: https://github.com/zd1181803971/zd1181803971.github.io.git branch: master 部署hexo d 重新生成 发布 hexo g hexo s hexo d ##参考文献 https://www.bilibili.com/video/BV1Yb411a7ty","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-10T03:19:45.303Z","updated":"2020-04-10T14:16:43.236Z","comments":true,"path":"2020/04/10/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}