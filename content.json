{"meta":{"title":"赵董の博客","subtitle":"记录学习生活中的点点滴滴","description":"能学就多学点吧","author":"ZhaoDong","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2020-04-10T09:49:18.743Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2020-04-10T09:47:46.446Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring","slug":"Spring","date":"2020-04-10T14:28:32.000Z","updated":"2020-04-15T12:18:59.899Z","comments":true,"path":"2020/04/10/Spring/","link":"","permalink":"http://yoursite.com/2020/04/10/Spring/","excerpt":"1、Spring","text":"1、Spring 1.1、简介 Spring：春天……》给软件行业带来了春天 2002年。首次推出了Spring框架的雏形，interface 21框架！ Spring框架以interface 21 框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版。 Rod Johnson ， Spring Framework创始人，著名作者。悉尼大学的博士，专业音乐学 spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！ SSH: Struct2 + Spring +Hibernate! SSM: SpringMVC + Spring +Mybatis! 官网：https://spring.io/projects/spring-framework 官方下载地址：https://repo.spring.io/release/org/springframework/spring/ GitHub：https://github.com/spring-projects/spring-framework 123456依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2、优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级、非入侵式的框架！ IoC全称Inversion of Control，直译为控制反转 Aspect Oriented Programming, 称为面向切面编程 支持事务的处理，对框架整合的支持！ 总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！ 1.3、组成Spring AOP Spring ORM Spring DAO Spring Web Spring Context Spring Web MVC Spring Core 七大模块 1.4、扩展现代化的Java开发，说白就是基于Spring的开发 Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速地开发单个微服务。 约定大于配置 Spring Cloud SpringCloud是基于SpringBoot实现的。 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！呈上启下的作用！ 弊端： 发展了太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱” 2、IOC理论推导 UserDao接口 UserDapImpl实现类 UserService业务接口 UserServiceImpl业务实现类 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！如果成勋代码量十分大，修改一次的成本代价十分昂贵！ 我们使用一个Set接口。已经发生了革命性的变化！ 1234// 利用set进行动态实现值的注入！ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！ 这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低~，可以更加专注的在业务的实现上！这是IOC的原型！ ICO本质控制反转loC(Inversion of Control),是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中,我们使用面向对象编程,对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是: 获得依赖对象的方式反转了。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的,而采用注解的方式可以把两者合为一体, Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述(XML或注解)并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反 转的是IoC容器,其实现方法是依赖注入(Dependency Injection,DI)。 3.HelloSpring1.plicationContext.xml配置文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"mysql\" class=\"com.dzu.dao.UserDaoMysqlImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"oracle\" class=\"com.dzu.dao.UserDaoOracleImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"userServiceImpl\" class=\"com.dzu.service.UserServiceImpl\"&gt; &lt;!--ref： 引用Spring容器中创建好的对象 value： 具体的值，基本数据类型 --&gt; &lt;property name=\"userDao\" ref=\"oracle\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 2.service层利用set动态注入dao 123456789101112public class UserServiceImpl implements UserService &#123; private UserDao userDao;// 利用set进行动态实现值的注入！ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void getUser() &#123; userDao.getUser(); &#125;&#125; 3.main函数调用 12345public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userServiceImpl = (UserService) context.getBean(\"userServiceImpl\"); userServiceImpl.getUser();&#125; 不用在程序中改动，要实现不同的操作，只需要在xml文件中进行修改，所谓的ioc，一句话搞定 ： 对象由Spring来创建，管理，装配！ 4.IOC创建对象的方式1.使用无参构造创建对象，默认！ 2.假设我们要使用有参构造创建对象。 1234&lt;!--第一种 下表赋值--&gt; &lt;bean id=\"user\" class=\"com.dzu.pojo.User\"&gt; &lt;constructor-arg index=\"0\" value=\"去问他\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 12345&lt;!--第二种 通过类型创建 不建议使用--&gt; &lt;bean id=\"user\" class=\"com.dzu.pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"qwe\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 1234&lt;!--第三种 直接通过参数名--&gt; &lt;bean id=\"user\" class=\"com.dzu.pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"zdd\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！ 5、Spring配置1.别名 alias 2.Bean的配置 123456&lt;!-- id : bean 的唯一标识符，也就是相当于我们学的对象名 class ： bean 对象所对应的全限定名 ： 包名+类型 name： 也是别名，而且name可以同时取多个别名--&gt;&lt;bean id=\"userT\" class=\"com.dzu.pojo.UserT\" name=\"userT2，u3,9798,hhg\"&gt;&lt;/bean&gt; 3.import 一般用于团队开发，它可以将多个配置文件，导入合并为一个 6、依赖注入1.构造器注入4.1 和 4.2 2.set方式注入【重点】 依赖注入： set注入 依赖： bean对象的创建依赖于容器 注入：bean对象中的所有属性，有容器来注入！ 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class Student &#123; private String name; private Address address; private String[] books; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", address=\" + address.toString() + \", books=\" + Arrays.toString(books) + \", card=\" + card + \", games=\" + games + \", wife='\" + wife + '\\'' + \", info=\" + info + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String[] getBooks() &#123; return books; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public Map&lt;String, String&gt; getCard() &#123; return card; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public Set&lt;String&gt; getGames() &#123; return games; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public Properties getInfo() &#123; return info; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"student\" class=\"com.dzu.pojo.Student\"&gt; &lt;property name=\"name\" value=\"zd\"&gt;&lt;/property&gt; &lt;property name=\"address\" ref=\"address\"&gt;&lt;/property&gt; &lt;property name=\"books\"&gt; &lt;list&gt; &lt;value&gt;java&lt;/value&gt; &lt;value&gt;go&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"ID\" value=\"11111111\"&gt;&lt;/entry&gt; &lt;entry key=\"银行\" value=\"2222222\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;SOS&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"wife\"&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"username\"&gt;fxf&lt;/prop&gt; &lt;prop key=\"url\"&gt;qqqqqq&lt;/prop&gt; &lt;prop key=\"password\"&gt;chidapi&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 3.扩展方式注入 p-namespace 或c-namespace 12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean name=\"classic\" class=\"com.example.ExampleBean\"&gt; &lt;property name=\"email\" value=\"someone@somewhere.com\"/&gt; &lt;/bean&gt; &lt;bean name=\"p-namespace\" class=\"com.example.ExampleBean\" p:email=\"someone@somewhere.com\"/&gt;&lt;/beans&gt; 4.Bean的作用域 Scope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. 单例模式（Spring默认机制） 原型模式：每次从容器中get的时候，都会产生一个新对象！ 其余的request、session、application 只能在web开发中使用到 7、Bean的自动装配 自动装配是Spring满足bean依赖一种方式 Spring会在上下文中自动寻找，并自动给Bean装配属性。 在Spring中 有三种自动装配的方式 在xml中显示的配置 在java中显示配置 隐式的自动装配bean 掌握 1.测试环境搭建：一个人有两个宠物。 2.byName自动装配1234 &lt;!--byName: 会自动在容器上下文中查找，和自己对象Set方法后面的值对应的Bean id！--&gt; &lt;bean id=\"people\" class=\"com.dzu.pojo.People\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"zd\"&gt;&lt;/property&gt;&lt;/bean&gt; 3.byType自动装配1234567891011&lt;bean id=\"dog\" class=\"com.dzu.pojo.Dog\"&gt;&lt;/bean&gt;&lt;bean id=\"cat\" class=\"com.dzu.pojo.Cat\"&gt;&lt;/bean&gt;&lt;!-- byName: 会自动在容器上下文中查找，和自己对象Set方法后面的值对应的Bean id！ byType: 会自动在容器上下文中查找，和自己对象属性类型相同的bean！ --&gt;&lt;bean id=\"people\" class=\"com.dzu.pojo.People\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"zd\"&gt;&lt;/property&gt;&lt;/bean&gt; 小结： byName、的时候，需要保证所有bean 的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！ byType、的时候，需要保证所有bean 的class唯一，并且这个bean需要和自动注入的属性的类型一致！ 4.使用注解实现自动装配jdk1.5支持的注解。Spring2.5就支持注解了 要使用注解须知： 导入约束,context约束 配置注解的支持： context:annotation-config/ 注解的支持 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！ 也可以在set方式上使用 使用Autowired 我们可以不用编写set方法，前提是你这个自动装配的属性在IOC（Spring） 容器中存在 12345678910 &lt;!--开启注解的支持--&gt; &lt;context:annotation-config/&gt; &lt;bean class=\"com.dzu.pojo.Dog\"&gt;&lt;/bean&gt; &lt;bean class=\"com.dzu.pojo.Cat\"&gt;&lt;/bean&gt; &lt;bean id=\"people\" class=\"com.dzu.pojo.People\"&gt;&lt;/bean&gt;&lt;/beans&gt; 1@Nullable 字段标记了这个注释，说明这个字段可以为null 1234@Autowired(required = fales) //如果显示定义了Autowired的required属性为false，说明这个对象可以为null。否则不能为空 public @interface Autowired &#123; boolean required() default true;&#125; 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用 @Qualifier(value = “xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入 123456public class People &#123; @Autowired @Qualifier(value = \"dog2\") private Dog dog;&#125; @Resource注解 12345678public class People &#123; private String name; @Resource private Cat cat; @Resource private Dog dog; 小结： @Resource注解和 @Autowired注解 的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired 通过byType的方式实现，如果有两个相同的bean，则通过byName。而且必须要求在这个对象存在【常用】 @Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况，就报错 执行顺序不同：@Autowired默认 通过byType的方式实现。。@Resource默认通过byName的方式实现 指定name的方式不一样，@Resource(name = &quot;baseDao&quot;),@Autowired()@Qualifier(&quot;baseDao&quot;) 8、使用注解开发在Spring4之后，要使用注解开发，必须要保证aop的包导入 使用注解需要导入context约束，增加注解的支持！ 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 1.bean 2.属性如何注入 1234567891011@Componentpublic class User &#123;// @Value(\"zd\") 在属性上也可以 public String name; //相当于 &lt;property name=\"name\" value=\"zd\"/&gt; @Value(\"zd\") public void setName(String name) &#123; this.name = name; &#125;&#125; 3.衍生的注解@Component 有几个衍生注解，我们在web开发中中，会按照mvc三层架构分层。 dao 【@Repository】 service 【@Service】 controller 【@Controller】 这四个注解的功能都是一样的，都是代表将某个类注册到Spring中，装配Bean。 4.自动装配置 @Autowired： @Autowired只有一个属性required，默认值为true，为true时，找不到就抛异常，为false时，找不到就赋值为null @Autowired按类型查找，如果该类型的bean不唯一，则抛出异常；可通过组合注解解决@Autowired()@Qualifier(&quot;baseDao&quot;) @Nullable：字段标记了这个注释，说明这个字段可以为null @Resource：自动装配默认通过名字，然后是类型 5.作用域 123456789101112@Component@Scope(\"prototype\")public class User &#123;// @Value(\"zd\") 在属性上也可以 public String name; //相当于 &lt;property name=\"name\" value=\"zd\"/&gt; @Value(\"zd\") public void setName(String name) &#123; this.name = name; &#125;&#125; 6.小结 xml与注解： xml更加万能，适用于任何场合！维护简单方便 注解不是自己类使用不了，维护相对复杂 xml与注解最佳实践： ​ xml用来管理bean； 注解只负责完成属性的注入； 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就要开启注解的支持； 9.使用Java的方式配置Spring我们现在要完全不使用Spring的xml配置了，全权交给java来做！ javaConfig是Spring 的一个子项目，在Spring4之后，他成为了一个核心功能！ 实体类 1234567891011121314151617181920//这个注解的意思，就是说明这个类被spring接管了，注册到了容器中@Componentpublic class User &#123; private String name; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; @Value(\"zd\")//属性注入值 public void setName(String name) &#123; this.name = name; &#125;&#125; 配置类 12345678910111213141516@Configuration//这个也会Spring容器托管，注册到容器中，因为他本来就是一个@Component//@Configuration代表这是一个配置类，就和我们之前看的beans.xml//组件扫描@ComponentScan(\"com.dzu.pojo\")@Import(FxfConfig.class)public class ZdConfig &#123; //注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean public User getUser()&#123; return new User();//就是返回要注入到bean的对象 &#125;&#125; 测试类 12345678910public class Test &#123; public static void main(String[] args) &#123; //如果完全使用了配置类方式去做，我们只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载 ApplicationContext context = new AnnotationConfigApplicationContext(ZdConfig.class); User user = context.getBean(\"getUser\", User.class); System.out.println(user.toString()); &#125;&#125; 这种纯java的配置方式，在SpringBoot中随处可见！ 10、代理模式为什么要学习代理模式？因为这就是SpringAOP的底层！ 代理模式的分类： 静态代理角色分析 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真实角色后，我们一般会坐附属操作 可恶：访问代理对象的人！ 代码步骤 1.接口 1234//租房public interface Rent &#123; void rent();&#125; 2.真实角色 1234567//房东public class Host implements Rent&#123; public void rent() &#123; System.out.println(\"房东要出租房子\"); &#125;&#125; 3.代理角色 1234567891011121314151617181920212223242526public class Proxy implements Rent&#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; public void rent() &#123; seeHouse(); host.rent(); hetong(); fare(); &#125; public void seeHouse()&#123; System.out.println(\"看房子\"); &#125; public void hetong()&#123; System.out.println(\"办合同\"); &#125; public void fare()&#123; System.out.println(\"收中介费\"); &#125;&#125; 4.客户端访问代理角色 123456789101112public class Client &#123; public static void main(String[] args) &#123; //房东要出租房子 Host host = new Host(); //房东交给中介，中介帮房东出租房子，但是中介要有附属操作，收钱 Proxy proxy = new Proxy(host); //你不用面对房东，直接找中介租房即可。 proxy.rent(); &#125;&#125; 代理模式的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共业务就交给代理角色！实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点： 一个真实角色就会产生一个代理角色；代码量会翻倍；开发效率会变低 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口——JDK动态代理【我们在这里使用】 基于类：cglib java字节码实现：javasist 需要了解两个类：Proxy：代理 ， InvocationHandler：调用处理程序 InvocationHandler 动态代理的好处 静态代理的所有好处 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要实现了同一个接口即可 11、AOPAOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。 在不改变原有的逻辑的基础上，增加一些额外的功能。代理也是这个功能，读写分离也能用aop来做。 AOP的相关概念： (1)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 (2)Aspect(切面):通常是一个类，里面可以定义切入点和通知 (3)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 (4)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕) (5)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式 (6)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程 (7)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 (8)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类 (9)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO 使用Spring实现AOP使用AOP织入，需要导入一个依赖包！ 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 方式一：使用Spring的API接口【主要是Spring API 接口实现】 123456789101112131415161718public class AfterLog implements AfterReturningAdvice &#123;// returnValue; 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(\"执行了\"+method.getName()+\"方法，返回结果为：\"+returnValue); &#125;&#125;===========================================public class Log implements MethodBeforeAdvice &#123; //method:要执行的目标对象的方法 //objects:参数 args //o：目标对象 target public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(o.getClass().getName()+\"&lt;de&gt;\"+method.getName()+\"执行了\"); &#125;&#125; 12345678910111213141516&lt;!--注册bean--&gt;&lt;bean id=\"userService\" class=\"com.dzu.service.UserServiceImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"log\" class=\"com.dzu.log.Log\"&gt;&lt;/bean&gt;&lt;bean id=\"afterLog\" class=\"com.dzu.log.AfterLog\"&gt;&lt;/bean&gt;&lt;!--方式一：使用原生Spring API接口--&gt;&lt;!--配置AOP，需要导入aop约束--&gt;&lt;aop:config&gt; &lt;!--切入点：expression表达式 ，execution(要执行的位置)--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.dzu.service.UserServiceImpl.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--执行环绕增加！--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:advisor&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 方式二：自定义来实现AOP 【主要是切面】 123456789public class DiyPointCut &#123; public void before()&#123; System.out.println(\"方法执行之前======\"); &#125; public void after()&#123; System.out.println(\"方法执行之后======\"); &#125;&#125; 1234567891011121314151617&lt;!--注册bean--&gt;&lt;bean id=\"userService\" class=\"com.dzu.service.UserServiceImpl\"&gt;&lt;/bean&gt;&lt;!--方式二，自定义类--&gt;&lt;bean id=\"diy\" class=\"com.dzu.diy.DiyPointCut\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;!--自定义切面类，ref要引用的类--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* com.dzu.service.UserServiceImpl.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--通知--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"&gt;&lt;/aop:before&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 方式三：使用注解实现 123456789101112131415161718192021//方式三：使用注解的方式实现AOp@Aspect //标注这个类是一个切面类public class AnnotationPointCut &#123; @Before(\"execution(* com.dzu.service.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"方法执行之前======\"); &#125; @After(\"execution(* com.dzu.service.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"方法执行之后======\"); &#125; //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点 @Around(\"execution(* com.dzu.service.UserServiceImpl.*(..))\") public void around()&#123; &#125;&#125; 1234567&lt;!--注册bean--&gt;&lt;bean id=\"userService\" class=\"com.dzu.service.UserServiceImpl\"&gt;&lt;/bean&gt;&lt;!--方式三，注解的方式--&gt;&lt;bean id=\"annotationPointCut\" class=\"com.dzu.diy.AnnotationPointCut\"&gt;&lt;/bean&gt;&lt;!--开启注解的支持 JDK（默认） cglib proxy-target-class=\"true\"--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 测试类 12345678910111213141516171819202122public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //动态代理的是接口！！ 注意点 UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); &#125; @org.junit.Test public void diyTest2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext2.xml\"); UserService userService = context.getBean(\"userService\", UserService.class); userService.delete(); &#125; @org.junit.Test public void diyTest3()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext3.xml\"); UserService userService = context.getBean(\"userService\", UserService.class); userService.delete(); &#125; 12、整合Mybatis 导入相关jar包 junit mybatis mysql数据库 spring相关 aop织入 mybatis-spring 编写配置文件 测试 回忆mybatis 编写实体类 编写核心配置文件 编写接口 编写Mapper.xml 测试 mybatis-spring 编写数据源配置 123456789&lt;!--DataSource： 使用Spring的数据源替换Mybatis的配置 c3po dbcp druid 我们这里使用Spring提供的JDBC --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; SqlSessionFactory 1234567&lt;!--SqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!--绑定Mybatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/dzu/mapper/UserMapper.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; SqlSessionTemplate 1234&lt;!--SqlSessionTemplate: 就是我们使用的SqlSession--&gt; &lt;bean id=\"sqlSessionTemplate\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 需要给接口加实现类【【 1234567public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; selectUser() &#123; return getSqlSession().getMapper(UserMapper.class).selectUser(); &#125;&#125; 将自己写的实现类，注入到Spring中 123&lt;bean id=\"userMapperImpl\" class=\"com.dzu.mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; 测试 1234567891011@Testpublic void test() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapperImpl2\", UserMapper.class); List&lt;User&gt; users = userMapper.selectUser(); for (User user : users) &#123; System.out.println(user); &#125;&#125; 13、声明式事务回顾事务： 把一组业务当成一个业务来做，要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎 确保完整性和一致性 事务ACID原则： 原子性 一致性 隔离性 多个业务可能操作同一个资源，房子数据损坏 持久性 事务一旦提交无论系统发生什么问题。结果都不会再被影响，被持久化的写到存储器中！ Spring中的事务管理 声明式事务： AOP 123456789101112131415161718192021222324&lt;!--配置声明式事务--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--&lt;constructor-arg ref=\"dataSource\"&gt;&lt;/constructor-arg&gt;--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--结合AOP实现事务的织入--&gt; &lt;!--配置事务通知；--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!--给哪些方法配置事务--&gt; &lt;!--配置事务的传播特性： new propagation默认REQUIRED--&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"del\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"query\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.dzu.mapper.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 编程式事务： 需要在代码中 进行事务的管理 思考： 为社么需要事务？ 如果不配置事务，可能存在数据提交不一致的情况下； 如果我们不在Spring中去配置声明式事务，我们就需要在代码中手动配置事务。 事务在项目的开发中十分重要，设计到数据的一致性和完整性问题，不容马虎！","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SringMVC","slug":"SringMVC","date":"2020-04-10T06:26:48.000Z","updated":"2020-04-20T11:11:29.194Z","comments":true,"path":"2020/04/10/SringMVC/","link":"","permalink":"http://yoursite.com/2020/04/10/SringMVC/","excerpt":"SpringMVC","text":"SpringMVC Spring MVC 的特点： 轻量级，简单易学 高效，基于请求响应的MVC框架 与Spring兼用型好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简单灵活 MVC即Model-View-Controller，将应用按照Model（模型）、View（视图）、Controller（控制）这样的方式分离。 中心控制器 ​ Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用java5或者以上版本的用户可以采用基于注解的controller声明方式。 ​ Spring MVC框架像许多其他的框架一样，以请求为驱动，围绕一个中心Servlet分派请求以及提供其他功能，DisparcherServlet是一个实际的Servlet（他继承自HttpServlet基类） HelloSpringMVC 新建一个Moudle，添加web的支持！ 确定导入了SpringMVC的依赖 12345678910111213141516171819202122232425262728293031&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置web.xml，注册DispatcherServlet 123456789101112131415 &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置xml文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"&gt;&lt;/bean&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"&gt;&lt;/bean&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"/hello\" class=\"com.dzu.controller.HelloController\"&gt;&lt;/bean&gt;&lt;/beans&gt; controller层 1234567891011public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"HelloMVC!\"); mv.setViewName(\"hello\"); return mv; &#125;&#125; 前端视图 了解原理即可，开发使用注解的方式！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat。 clean一下 使用SpringMVC必须配置的三大件： 处理器映射器 1&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"&gt;&lt;/bean&gt; 处理器适配器 1&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"&gt;&lt;/bean&gt; 视图解析器 1234&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 流程1、用户发送请求至前端控制器DispatcherServlet。 2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、 DispatcherServlet调用HandlerAdapter处理器适配器。 5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 6、Controller执行完成返回ModelAndView。 7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 9、ViewReslover解析后返回具体View. 10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 11、DispatcherServlet响应用户。 注解的方式 新建一个web项目 导入相关jar包 编写web.xml,注册DispatcherServlet 编写springmvc配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt; &lt;context:component-scan base-package=\"com.dzu.controller\"&gt;&lt;/context:component-scan&gt; &lt;!--让Spring MVC不处理静态资源 .css .js .html .mp3 .mp4...--&gt; &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt; &lt;!--支持mvc注解驱动 再spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别再类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建相应的控制类，controller 12345678910@Controllerpublic class HelloController &#123; @RequestMapping(\"/h1\") public String hello(Model model)&#123; //封装数据 model.addAttribute(\"msg\",\"hellokkkmvc\"); return \"hello\";//会被视图解析器处理 &#125;&#125; 完善前端视图和controller之间的对应 测试运行调试 Controller@Component 组件 @Service service @Controller Controller @Repository dao 12345LinkedHashMap:ModelMap:继承了LinkedHashMap,所以它拥有LinkedHashMap的全部功能Model: 精简版，大部分情况，我们都直接使用Model RestFul风格RestFul就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 使路径变得更加简洁 获得参数更加方便，框架会自动进行类型转换 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如果这里访问的路径是/commit/1/a,则路径与方法不匹配，而不会是参数转换失败。 结果跳转方式ModelAndView设置ModelAndView对象，根据view的名称，和视图解析器跳到指定的页面 页面： {视图解析器前缀} + viewName + {视图解析器后缀} 不使用视图解析器：非常用 return “/WEB-INF/jsp/xxx.jsp” 转发的方式 return “forward:/WEB-INF/jsp/xxx.jsp” 也是转发 return “redirect:/xxx.jsp 解决乱码问题12345678910111213 &lt;!--配置SpringMVC的乱码过滤--&gt;&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Controller反回JSON数据jackson比较好用的json解析工具 工具不止一个，还有阿里巴巴的fastjson等等 我们这里使用jackson，需要导入他的jar包 12345678910111213&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.37&lt;/version&gt;&lt;/dependency&gt; ssm整合 需求分析 - 创建数据库 mybatis spring整合mybatis springmvc 前端页面 AJAX AJAX = Asynchronous JavaScript and XML (异步的JavaScript和XML) AJAX是一种在无需重新加载整个页面的情况下，能够更新部分网页的技术 AJAX不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的WEB应用程序的技术。 使用aiax技术的网页，通过后台服务器进行少量的数据交换，就可以实现异步布局更新 使用ajax，用户可以创建接近本地桌面应用的直接，高可用，更丰富，更动态的Web用户界面 JQuery是一个库，js的大量函数（方法） 拦截器SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。开发者可以自定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别： 拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法，如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器要想自定义拦截器，必须实现HandlerInterceptor","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Mybatis","slug":"Mybatis","date":"2020-04-10T04:52:42.000Z","updated":"2020-04-13T06:34:05.699Z","comments":true,"path":"2020/04/10/Mybatis/","link":"","permalink":"http://yoursite.com/2020/04/10/Mybatis/","excerpt":"Mybatis","text":"Mybatis 源码已上传：https://github.com/zd1181803971/Mybatis 1.Mybatis环境说明、 jdk 8+ MySQL 5.7.19 maven-3.5.2 IDEA 2018.3.6 2.什么是MyBatis、 MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3、 3.MyBatis入门程序b站视频地址：https://www.bilibili.com/video/BV1NE411Q7Nx 导入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 主配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--mybatis主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的4个基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF8\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/dzu/mapper/CustomerMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Dao层接口方法对应的xml配置文 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dzu.dao.IUserDao\"&gt; &lt;!--配置查询所有 id是IUserDao里面的方法名称--&gt; &lt;!--mybatis的映射配置文件位置必须和dao接口的包结构相同 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 映射配置文件的操作配置（select） id 属性的取值必须是dao接口的方法名 无需再写dao的实现类 --&gt; &lt;select id=\"findAll\" resultType=\"com.dzu.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类 1234567891011121314151617181920212223public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 //SqlSessionFactoryBuilder一旦创建了SqlSessionFactory，就不再需要他了 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，默认单例模式 SqlSessionFactory factory = builder.build(in); //3.使用工厂生产一个SqlSession对象 //每次收到http请求，就可以打开一个SqlSession。所以关闭操作很重要 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 CustomerMapper csm = session.getMapper(CustomerMapper.class); //5，使用代理对象执行方法 List&lt;User&gt; users = csm.findAll(); for (User user : users) System.out.println(user); //6.释放资源 session.close(); in.close(); &#125;&#125; 4.可能出现问题说明：Maven静态资源过滤问题 ​ Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource CustomerMapper.xml 123456789101112131415161718&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 可能遇到的问题 配置文件没有注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 5.CRUD namespace namespace中的包名要和Dao/Mapper接口的包名一致！ select 查询语句 id：就是对应的namespace中的方法名； resultType： Sql语句执行的返回值！ parameterType: 参数类型 多个参数用Map 或者注解 编写接口 编写对应的mapper中的sql语句 测试 注意增删改commit的提交！！！ 标签不要匹配错 程序配置文件必须符合规范 资源路径 resource绑定mapper使用路径 6.配置解析1.核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 元素类型为 “configuration” 的内容必须匹配 “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”。 2.环境配置（environments）Mybatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，单每个SqlSessionFactory实例只能选择一种环境 Mybatis默认的事务管理器就是JDBC， 连接池 ： POOLED 3.属性（properties）我们可以通过properties属性来引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性。【db.properties】 编写一个配置文件 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisusername=rootpassword=root 在核心配置文件进行引入 12345&lt;!--引入外部配置文件 优先使用--&gt;&lt;properties resource=\"db.properties\"&gt; &lt;property name=\"u\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"p\" value=\"root\"&gt;&lt;/property&gt;&lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置的！ 4.类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 扫描实体类的包，他的默认别名就为这个类的 类名 首字母小写 12345&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;!--&lt;typeAlias type=\"com.dzu.pojo.User\" alias=\"User\"&gt;&lt;/typeAlias&gt;--&gt; &lt;package name=\"com.dzu.pojo\" &gt;&lt;/package&gt;&lt;/typeAliases&gt; 实体类少的时候 用第一种 实体类多 第二种 第一种可以DIY起名 第二种不行，如果非要改，在实体类上增加注释 12@Alias(\"user\")public class User &#123; 5.设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 6.其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） mybatis-generator-core mybatis-plus 通用mapper 7.映射器（mappers）MapperRegistry：注册绑定我们的Mapper文件 1.[推荐使用，大多数] 1234&lt;!--每一个Mapper。xml都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 2.使用class文件绑定注册 1234&lt;mappers&gt; &lt;!--&lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;--&gt; &lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 注意点 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 3.使用扫描包进行注入绑定 12345&lt;mappers&gt; &lt;!--&lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;--&gt; &lt;package name=\"com.dzu.mapper\"&gt;&lt;/package&gt;&lt;/mappers&gt; 注意点 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 练习 将数据库配置文件外部引入 实体类别名 保证UserMapper接口和UserMapper.xml保持一致，并放在同一个包下 8.生命周期和作用域生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBulider 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory 说白了就是可以想象为：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 SqlSessionFactory 的最佳作用域是应用作用域 最简单的就是使用单例模式或者静态单例模式。 SqlSession 连接到连接池的一个请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后赶紧关闭，否则资源被占用 SqlSessionFactory可以open多个SqlSession，SqlSession也能get多个Mapper 每一个Mapper，就代表一个具体的业务！ 7.解决属性名和字段名不一致的问题解决方案 起别名 123&lt;select id=\"findUserById\" resultType=\"user\" parameterType=\"int\"&gt; select id,name,pwd as password from user where id = #&#123;id&#125;;&lt;/select&gt; resultMap结果集映射 123456789101112&lt;!--结果集映射--&gt;&lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!--column数据库中的字段 property实体类中的属性--&gt; &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;result column=\"pwd\" property=\"password\"&gt;&lt;/result&gt;&lt;/resultMap&gt; &lt;select id=\"findUserById\" resultMap=\"UserMap\" parameterType=\"int\"&gt; select * from user where id = #&#123;id&#125;;&lt;/select&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们 如果这个世界总是这么简单就好了。 8.日志1.日志工厂如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手。 SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在mybatis中具体使用哪一个日志实现，在设置中设定 STDOUT_LOGGING 标准日志输出 在Mybatis核心配置文件中，配置我们的日志 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; 2.Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等； 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 导入log4j的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties文件的配置 简单使用 在要使用Log4j的类中，导入包import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(Test.class); 日志级别 123logger.info(\"info\");logger.debug(\"debug\");logger.error(\"error\"); 9.分页1.为什么要分页 减少数据的处理量 2.使用Limit分页1语法：select * from mybatis.user limit startIndex,pageSize; 使用Mybatis实现分页，核心SQL 1.接口 1List&lt;User&gt; getUserLimit(Map&lt;String,Integer&gt; map); 2.Mapper.xml 123&lt;select id=\"getUserLimit\" parameterType=\"map\" resultType=\"User\"&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;/select&gt; 3.测试 12345678910SqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);HashMap&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();map.put(\"startIndex\",0);map.put(\"pageSize\",1);List&lt;User&gt; users = mapper.getUserLimit(map);for (User user : users) &#123; System.out.println(user);&#125;sqlSession.close(); 10.使用注解开发面向接口编程； 解耦，可扩展，提高复用，分层开发 1.注解在接口上实现 12@Select(\"select * from user\")List&lt;User&gt; getUsers(); 2.需要在核心配置文件中绑定接口 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 本质：反射机制实现 底层：动态代理 关于@param()注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个类型的话，可以忽略，建议加上 我们在SQL中引用的就是我们这里的@Param()中设定的属性名 11.Mybatis执行流程Resources获取加载全局配置文件 实例化SqlsessionFactoryBuilder构造器 解析文件流XMLConfigBuilder Configuration所有的配置信息 SqlSessionFactory实例化 transactional事务管理 创建executor执行器 创建SqlSession 实现CRUD false则回滚 是否执行成功 false则回滚 提交事务 关闭 12.多对一处理测试环境搭建12345678910111213141516171819202122create table teacher( id int(10) not null, name varchar(30) default null, primary key (id)) engine=innodb default charset=utf8insert into teacher(id,name) values (1,'赵老师');create table student( id int(10) not null, name varchar(30) default null, tid int(10) default null, primary key (id), key fktid (tid), constraint fktid foreign key (tid) references teacher(id))engine=innodb default charset=utf8insert into student(id,name,tid) values (1,'小明',1);insert into student(id,name,tid) values (2,'小等',1);insert into student(id,name,tid) values (3,'小的',1);insert into student(id,name,tid) values (4,'小给',1);insert into student(id,name,tid) values (5,'小和',1); 导入lombok 新建实体类Teacher,Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件 测试查询能否成功 按照查询嵌套处理12345678910111213141516&lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from student;&lt;/select&gt;&lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"name\"&gt;&lt;/result&gt; &lt;!--复杂的属性，我们需要单独处理--&gt; &lt;!--对象： association 集合： collection --&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from teacher where id = #&#123;id&#125;;&lt;/select&gt; 按照结果嵌套处理12345678910111213&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid,s.name sname,t.id tid ,t.name tname from student s ,teacher t where s.tid = t.id ; &lt;/select&gt; &lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"sname\"&gt;&lt;/result&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"id\" column=\"tid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"tname\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 13.一对多处理比如：一个老师拥有多个学生 对于老师而言，就是一对多的关系。 搭建环境 和刚才一样 实体类 123456@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 12345678@Datapublic class Teacher &#123; private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students;&#125; 按照结果嵌套处理 12345678910111213141516171819202122&lt;!--按照结果嵌套查询--&gt;&lt;select id=\"getTeacher\" resultMap=\"TeacherStudent\"&gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=\"TeacherStudent\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"tid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"tname\"&gt;&lt;/result&gt; &lt;!--复杂的属性，我们需要单独处理--&gt; &lt;!--对象： association 集合： collection javaType 指定属性的类型！ 集合中的泛型信息 我们使用ofType获取 --&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"sname\"&gt;&lt;/result&gt; &lt;result property=\"tid\" column=\"tid\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理 12345678910111213&lt;select id=\"getTeacher2\" resultMap=\"TeacherStudent2\"&gt; select * from teacher where id =#&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=\"TeacherStudent2\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentsByTeacherID\" column=\"id\"&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"getStudentsByTeacherID\" resultType=\"Student\"&gt; select * from student where tid = #&#123;tid&#125;&lt;/select&gt; 小结 关联- association【多对一】 集合- collection javaType &amp; ofType 1.javaType 用来指定实体类中属性的类型 2.ofType 用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！ 注意点保证SQL的可读性，尽量保证通俗易懂！注意一对多和多对一中，属性名和字段的问题！如果问题不好排查错误，可以使用日志，建议Log4j 面试高频Mysql引擎innoDB底层原理索引索引优化！ 14.动态SQL什么是动态sql： 动态sql就是根据不同的条件生成不同的sql语句 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach 搭建环境1234567create table blog( id varchar(50) not null comment '博客id', title varchar(100) not null comment '博客标题', author varchar(30) not null comment '博客作者', create_time datetime not null comment '创建时间', views int(30) not null comment '浏览量')engine=innodb default charset=utf8; 创建一个基础工程 导包 编写配置文件 编写实体类 12345678@Datapublic class Blog &#123; private int id; private String title; private String author; private Date createTime; private int views;&#125; 编写实体类对应Mapper接口和Mapper.xml文件 IF123456789&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog where 1=1 &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; trim (where, set)set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 1234567891011&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 123456789101112&lt;update id=\"updateBlog\" parameterType=\"map\"&gt; update blog &lt;set&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; author =#&#123;author&#125; &lt;/if&gt; where id = #&#123;id&#125; &lt;/set&gt;&lt;/update&gt; choose (when, otherwise)123456789101112131415161718传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就 按 otherwise 里面的查找&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title != null\"&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views =#&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 所谓的动态SQL, 本只还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 SQL片段有的时候 我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 12345678&lt;sql id=\"if-title-author\"&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author =#&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 在需要使用的地方使用include标签引用即可 123456&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; 注意事项 最好基于单表来定义SQL片段 sql标签内 不要存在where标签 foreach12345678910官网：&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 123456789&lt;!--我们传递一个万能Map，里面存在一个集合--&gt;&lt;select id=\"queryBlogForeach\" resultType=\"Blog\" parameterType=\"map\"&gt; select * from blog &lt;where&gt; &lt;foreach collection=\"mid\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mybatis中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可 15.缓存Mybatis缓存 MyBatis包含- 个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效 MyBatis系统中默认定义了两级缓存: 一级缓存和二级缓存 1、默认情况下，只有一级缓存开启。(SqlSession级别的缓存, 也称为本地缓存) 2、二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 3、为了提高扩展性, MyBatis定义了缓存接口Cache.我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存：SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤 开启日志 测试再一个Session、中查询两次相同的记录 查看日志输出 12345678910111213Opening JDBC ConnectionCreated connection 238157928.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)===============User(id=1, name=zd, pwd=123)true &gt;&gt;&gt; user == user2Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@e320068]Returned connection 238157928 to pool. 缓存失效的情况 查询不同的东西 曾删改操作，可能会改变原来的数据，所以必定会刷新缓存 123456789101112131415161718192021Opening JDBC ConnectionCreated connection 32863545.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)==&gt; Preparing: update mybatis.user set name=?,pwd=? where id = ? ==&gt; Parameters: aaa(String), nnn(String), 2(Integer)&lt;== Updates: 1=================&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)false 》》》 缓存刷新 两个User不相等Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1f57539]Returned connection 32863545 to pool. 查询不同的Mapper.xml 手动清理缓存：SqlSession.clearCache(); 123456789101112131415161718Opening JDBC ConnectionCreated connection 32863545.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)=================&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)falseClosing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1f57539]Returned connection 32863545 to pool. 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个Map 二级缓存●二级缓存也叫全局缓存, -级缓存作用域太低了,所以诞生了二级缓存 ●基于namespace级别的缓存，-个名称空间，对应一个二 级缓存; ●工作机制 一个会话查询一条数据,这个数据就会被放在当前会话的- -级缓存中; 如果当前会话关闭了，这个会话对应的一-级缓存就没了;但是我们想要的是,会话关闭了，一级缓存中的数据被保存到二级缓存中; 新的会话查询信息，就可以从二级缓存中获取内容; 不同的mapper查出的数据会放在自己对应的缓存(map) 中； 步骤 开启全局缓存 12&lt;!--显示的开启全局缓存--&gt; &lt;setting name=\"cacheEnable\" value=\"true\"&gt;&lt;/setting&gt; 在要使用二级缓存Mapper中开启 12&lt;!--在当前Mapper.xml中，使用二级缓存--&gt;&lt;cache&#x2F;&gt; 也可以自定义参数 123456&lt;!--在当前Mapper.xml中，使用二级缓存--&gt;&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 测试1.问题： 我们需要将实体类序列化！否者就会报错 1Caused by: java.io.NotSerializableException: com.dzu.pojo.User 小结 只要开启了二级缓存，在同一个Mapper下就有效； 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓存中； 缓存原理用户首先从二级缓存中查找数据，如果没有查到，就去一级缓存查找，还没有就去数据库中查找。 然后将在数据库中查找的数据放到一级缓存中，供当前SqlSession使用， 当关闭SqlSesion，一级缓存的内容会加入到二级缓存中，此时 二级缓存为整个Mapper服务 自定义缓存-ehcacheEhcache是一种广泛使用的开源Java分布式缓存，主要面向通用缓存 要在程序中导包 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"如何搭建Hexo简单教程","slug":"我的第一篇博客文章","date":"2020-04-10T03:23:21.000Z","updated":"2020-04-10T14:16:25.646Z","comments":true,"path":"2020/04/10/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/04/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"##如何搭建Hexo 简单搭建Hexo","text":"##如何搭建Hexo 简单搭建Hexo 安装nods.js 进入cmd，npm外网太慢，用taobaonpm install -g cnpm –registry=https://registry.npm.taobao.org 安装hexocnpm install -g hexo-cli 初始化hexohexo init 启动hexo s 创建新的博客 hexo n ##将hexo发布到github 安装 gitcnpm install –save hexo-deployer-git 修改_config.yml文件 type: git repo: https://github.com/zd1181803971/zd1181803971.github.io.git branch: master 部署hexo d 重新生成 发布 hexo g hexo s hexo d ##参考文献 https://www.bilibili.com/video/BV1Yb411a7ty","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-10T03:19:45.303Z","updated":"2020-04-10T14:16:43.236Z","comments":true,"path":"2020/04/10/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}