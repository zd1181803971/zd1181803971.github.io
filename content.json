{"meta":{"title":"赵董の博客","subtitle":"记录学习生活中的点点滴滴","description":"能学就多学点吧","author":"ZhaoDong","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2020-04-10T09:47:46.446Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2020-04-10T09:49:18.743Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring","slug":"Spring","date":"2020-04-10T14:28:32.000Z","updated":"2020-04-14T13:29:47.281Z","comments":true,"path":"2020/04/10/Spring/","link":"","permalink":"http://yoursite.com/2020/04/10/Spring/","excerpt":"1、Spring","text":"1、Spring 1.1、简介 Spring：春天……》给软件行业带来了春天 2002年。首次推出了Spring框架的雏形，interface 21框架！ Spring框架以interface 21 框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版。 Rod Johnson ， Spring Framework创始人，著名作者。悉尼大学的博士，专业音乐学 spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！ SSH: Struct2 + Spring +Hibernate! SSM: SpringMVC + Spring +Mybatis! 官网：https://spring.io/projects/spring-framework 官方下载地址：https://repo.spring.io/release/org/springframework/spring/ GitHub：https://github.com/spring-projects/spring-framework 123456依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2、优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级、非入侵式的框架！ IoC全称Inversion of Control，直译为控制反转 Aspect Oriented Programming, 称为面向切面编程 支持事务的处理，对框架整合的支持！ 总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！ 1.3、组成Spring AOP Spring ORM Spring DAO Spring Web Spring Context Spring Web MVC Spring Core 七大模块 1.4、扩展现代化的Java开发，说白就是基于Spring的开发 Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速地开发单个微服务。 约定大于配置 Spring Cloud SpringCloud是基于SpringBoot实现的。 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！呈上启下的作用！ 弊端： 发展了太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱” 2、IOC理论推导 UserDao接口 UserDapImpl实现类 UserService业务接口 UserServiceImpl业务实现类 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！如果成勋代码量十分大，修改一次的成本代价十分昂贵！ 我们使用一个Set接口。已经发生了革命性的变化！ 1234// 利用set进行动态实现值的注入！ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！ 这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低~，可以更加专注的在业务的实现上！这是IOC的原型！ ICO本质控制反转loC(Inversion of Control),是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中,我们使用面向对象编程,对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是: 获得依赖对象的方式反转了。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的,而采用注解的方式可以把两者合为一体, Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述(XML或注解)并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反 转的是IoC容器,其实现方法是依赖注入(Dependency Injection,DI)。 3.HelloSpring1.plicationContext.xml配置文件 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"mysql\" class=\"com.dzu.dao.UserDaoMysqlImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"oracle\" class=\"com.dzu.dao.UserDaoOracleImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"userServiceImpl\" class=\"com.dzu.service.UserServiceImpl\"&gt; &lt;!--ref： 引用Spring容器中创建好的对象 value： 具体的值，基本数据类型 --&gt; &lt;property name=\"userDao\" ref=\"oracle\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 2.service层利用set动态注入dao 123456789101112public class UserServiceImpl implements UserService &#123; private UserDao userDao;// 利用set进行动态实现值的注入！ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void getUser() &#123; userDao.getUser(); &#125;&#125; 3.main函数调用 12345public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userServiceImpl = (UserService) context.getBean(\"userServiceImpl\"); userServiceImpl.getUser();&#125; 不用在程序中改动，要实现不同的操作，只需要在xml文件中进行修改，所谓的ioc，一句话搞定 ： 对象由Spring来创建，管理，装配！ 4.IOC创建对象的方式1.使用无参构造创建对象，默认！ 2.假设我们要使用有参构造创建对象。 1234&lt;!--第一种 下表赋值--&gt; &lt;bean id=\"user\" class=\"com.dzu.pojo.User\"&gt; &lt;constructor-arg index=\"0\" value=\"去问他\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 12345&lt;!--第二种 通过类型创建 不建议使用--&gt; &lt;bean id=\"user\" class=\"com.dzu.pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"qwe\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 1234&lt;!--第三种 直接通过参数名--&gt; &lt;bean id=\"user\" class=\"com.dzu.pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"zdd\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！ 5、Spring配置1.别名 alias 2.Bean的配置 123456&lt;!-- id : bean 的唯一标识符，也就是相当于我们学的对象名 class ： bean 对象所对应的全限定名 ： 包名+类型 name： 也是别名，而且name可以同时取多个别名--&gt;&lt;bean id=\"userT\" class=\"com.dzu.pojo.UserT\" name=\"userT2，u3,9798,hhg\"&gt;&lt;/bean&gt; 3.import 一般用于团队开发，它可以将多个配置文件，导入合并为一个 6、依赖注入1.构造器注入见HelloSpring 2.set方式注入【重点】 依赖注入： set注入 依赖： bean对象的创建依赖于容器 注入：bean对象中的所有属性，有容器来注入！ 测试类 123456789101112public class Student &#123; private String name; private Address address; private String[] books; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public class Address &#123; private String address; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"address\" class=\"com.dzu.pojo.Address\"&gt; &lt;property name=\"address\" value=\"ShanDong\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"student\" class=\"com.dzu.pojo.Student\"&gt; &lt;property name=\"name\" value=\"zd\"&gt;&lt;/property&gt; &lt;property name=\"address\" ref=\"address\"&gt;&lt;/property&gt; &lt;property name=\"books\"&gt; &lt;list&gt; &lt;value&gt;java&lt;/value&gt; &lt;value&gt;go&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"ID\" value=\"11111111\"&gt;&lt;/entry&gt; &lt;entry key=\"银行\" value=\"2222222\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;SOS&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"wife\"&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"username\"&gt;fxf&lt;/prop&gt; &lt;prop key=\"url\"&gt;qqqqqq&lt;/prop&gt; &lt;prop key=\"password\"&gt;chidapi&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 3.扩展方式注入 p-namespace 或c-namespace 12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean name=\"classic\" class=\"com.example.ExampleBean\"&gt; &lt;property name=\"email\" value=\"someone@somewhere.com\"/&gt; &lt;/bean&gt; &lt;bean name=\"p-namespace\" class=\"com.example.ExampleBean\" p:email=\"someone@somewhere.com\"/&gt;&lt;/beans&gt; 4.Bean的作用域 Scope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. 单例模式（Spring默认机制） 原型模式：每次从容器中get的时候，都会产生一个新对象！ 其余的request、session、application 只能在web开发中使用到 7、Bean的自动装配 自动装配是Spring满足bean依赖一种方式 Spring会在上下文中自动寻找，并自动给Bean装配属性。 在Spring中 有三种自动装配的方式 在xml中显示的配置 在java中显示配置 隐式的自动装配bean 掌握 1.测试环境搭建：一个人有两个宠物。 2.byName自动装配1234 &lt;!--byName: 会自动在容器上下文中查找，和自己对象Set方法后面的值对应的Bean id！--&gt; &lt;bean id=\"people\" class=\"com.dzu.pojo.People\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"zd\"&gt;&lt;/property&gt;&lt;/bean&gt; 3.byType自动装配1234567891011&lt;bean id=\"dog\" class=\"com.dzu.pojo.Dog\"&gt;&lt;/bean&gt;&lt;bean id=\"cat\" class=\"com.dzu.pojo.Cat\"&gt;&lt;/bean&gt;&lt;!-- byName: 会自动在容器上下文中查找，和自己对象Set方法后面的值对应的Bean id！ byType: 会自动在容器上下文中查找，和自己对象属性类型相同的bean！ --&gt;&lt;bean id=\"people\" class=\"com.dzu.pojo.People\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"zd\"&gt;&lt;/property&gt;&lt;/bean&gt; 小结： byName、的时候，需要保证所有bean 的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！ byType、的时候，需要保证所有bean 的class唯一，并且这个bean需要和自动注入的属性的类型一致！ 4.使用注解实现自动装配jdk1.5支持的注解。Spring2.5就支持注解了 要使用注解须知： 导入约束,context约束 配置注解的支持： context:annotation-config/ 注解的支持 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！ 也可以在set方式上使用 使用Autowired 我们可以不用编写set方法，前提是你这个自动装配的属性在IOC（Spring） 容器中存在 12345678910 &lt;!--开启注解的支持--&gt; &lt;context:annotation-config/&gt; &lt;bean class=\"com.dzu.pojo.Dog\"&gt;&lt;/bean&gt; &lt;bean class=\"com.dzu.pojo.Cat\"&gt;&lt;/bean&gt; &lt;bean id=\"people\" class=\"com.dzu.pojo.People\"&gt;&lt;/bean&gt;&lt;/beans&gt; 1@Nullable 字段标记了这个注释，说明这个字段可以为null 1234@Autowired(required = fales) //如果显示定义了Autowired的required属性为false，说明这个对象可以为null。否则不能为空 public @interface Autowired &#123; boolean required() default true;&#125; 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用 @Qualifier(value = “xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入 123456public class People &#123; @Autowired @Qualifier(value = \"dog2\") private Dog dog;&#125; @Resource注解 12345678public class People &#123; private String name; @Resource private Cat cat; @Resource private Dog dog; 小结： @Resource注解和 @Autowired注解 的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired 通过byType的方式实现，如果有两个相同的bean，则通过byName。而且必须要求在这个对象存在【常用】 @Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况，就报错 执行顺序不同：@Autowired默认 通过byType的方式实现。。@Resource默认通过byName的方式实现 指定name的方式不一样，@Resource(name = &quot;baseDao&quot;),@Autowired()@Qualifier(&quot;baseDao&quot;) 8、使用注解开发在Spring4之后，要使用注解开发，必须要保证aop的包导入 使用注解需要导入context约束，增加注解的支持！ 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 1.bean 2.属性如何注入 1234567891011@Componentpublic class User &#123;// @Value(\"zd\") 在属性上也可以 public String name; //相当于 &lt;property name=\"name\" value=\"zd\"/&gt; @Value(\"zd\") public void setName(String name) &#123; this.name = name; &#125;&#125; 3.衍生的注解@Component 有几个衍生注解，我们在web开发中中，会按照mvc三层架构分层。 dao 【@Repository】 service 【@Service】 controller 【@Controller】 这四个注解的功能都是一样的，都是代表将某个类注册到Spring中，装配Bean。 4.自动装配置 @Autowired： @Autowired只有一个属性required，默认值为true，为true时，找不到就抛异常，为false时，找不到就赋值为null @Autowired按类型查找，如果该类型的bean不唯一，则抛出异常；可通过组合注解解决@Autowired()@Qualifier(&quot;baseDao&quot;) @Nullable：字段标记了这个注释，说明这个字段可以为null @Resource：自动装配默认通过名字，然后是类型 5.作用域 123456789101112@Component@Scope(\"prototype\")public class User &#123;// @Value(\"zd\") 在属性上也可以 public String name; //相当于 &lt;property name=\"name\" value=\"zd\"/&gt; @Value(\"zd\") public void setName(String name) &#123; this.name = name; &#125;&#125; 6.小结 xml与注解： xml更加万能，适用于任何场合！维护简单方便 注解不是自己类使用不了，维护相对复杂 xml与注解最佳实践： ​ xml用来管理bean； 注解只负责完成属性的注入； 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就要开启注解的支持； 9.使用Java的方式配置Spring我们现在要完全不使用Spring的xml配置了，全权交给java来做！ javaConfig是Spring 的一个子项目，在Spring4之后，他成为了一个核心功能！ 实体类 1234567891011121314151617181920//这个注解的意思，就是说明这个类被spring接管了，注册到了容器中@Componentpublic class User &#123; private String name; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; @Value(\"zd\")//属性注入值 public void setName(String name) &#123; this.name = name; &#125;&#125; 配置类 123456789101112131415@Configuration//这个也会Spring容器托管，注册到容器中，因为他本来就是一个@Component//@Configuration代表这是一个配置类，就和我们之前看的beans.xml@ComponentScan(\"com.dzu.pojo\")@Import(FxfConfig.class)public class ZdConfig &#123; //注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签中的class属性 @Bean public User getUser()&#123; return new User();//就是返回要注入到bean的对象 &#125;&#125; 测试类 12345678910public class Test &#123; public static void main(String[] args) &#123; //如果完全使用了配置类方式去做，我们只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载 ApplicationContext context = new AnnotationConfigApplicationContext(ZdConfig.class); User user = context.getBean(\"getUser\", User.class); System.out.println(user.toString()); &#125;&#125; 这种纯java的配置方式，在SpringBoot中随处可见！ 10、代理模式为什么要学习代理模式？因为这就是SpringAOP的底层！ 代理模式的分类： 静态代理角色分析 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真实角色后，我们一般会坐附属操作 可恶：访问代理对象的人！ 代码步骤 1.接口 1234//租房public interface Rent &#123; void rent();&#125; 2.真实角色 1234567//房东public class Host implements Rent&#123; public void rent() &#123; System.out.println(\"房东要出租房子\"); &#125;&#125; 3.代理角色 1234567891011121314151617181920212223242526public class Proxy implements Rent&#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; public void rent() &#123; seeHouse(); host.rent(); hetong(); fare(); &#125; public void seeHouse()&#123; System.out.println(\"看房子\"); &#125; public void hetong()&#123; System.out.println(\"办合同\"); &#125; public void fare()&#123; System.out.println(\"收中介费\"); &#125;&#125; 4.客户端访问代理角色 123456789101112public class Client &#123; public static void main(String[] args) &#123; //房东要出租房子 Host host = new Host(); //房东交给中介，中介帮房东出租房子，但是中介要有附属操作，收钱 Proxy proxy = new Proxy(host); //你不用面对房东，直接找中介租房即可。 proxy.rent(); &#125;&#125; 代理模式的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共业务就交给代理角色！实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点： 一个真实角色就会产生一个代理角色；代码量会翻倍；开发效率会变低 动态代理","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SringMVC","slug":"SringMVC","date":"2020-04-10T06:26:48.000Z","updated":"2020-04-10T14:27:23.484Z","comments":true,"path":"2020/04/10/SringMVC/","link":"","permalink":"http://yoursite.com/2020/04/10/SringMVC/","excerpt":"SpringMVC入门程序","text":"SpringMVC入门程序 环境搭建 导入依赖 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 修改web.xml 1234567891011121314151617181920212223242526272829&lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; SpringMVC配置文件 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开始注释扫描--&gt; &lt;context:component-scan base-package=\"cn.dzu\"&gt;&lt;/context:component-scan&gt; &lt;!--视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启SpringMVC框架注释的支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; To be continued…","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Mybatis","slug":"Mybatis","date":"2020-04-10T04:52:42.000Z","updated":"2020-04-13T06:34:05.699Z","comments":true,"path":"2020/04/10/Mybatis/","link":"","permalink":"http://yoursite.com/2020/04/10/Mybatis/","excerpt":"Mybatis","text":"Mybatis 源码已上传：https://github.com/zd1181803971/Mybatis 1.Mybatis环境说明、 jdk 8+ MySQL 5.7.19 maven-3.5.2 IDEA 2018.3.6 2.什么是MyBatis、 MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3、 3.MyBatis入门程序b站视频地址：https://www.bilibili.com/video/BV1NE411Q7Nx 导入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 主配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--mybatis主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的4个基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF8\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/dzu/mapper/CustomerMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Dao层接口方法对应的xml配置文 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dzu.dao.IUserDao\"&gt; &lt;!--配置查询所有 id是IUserDao里面的方法名称--&gt; &lt;!--mybatis的映射配置文件位置必须和dao接口的包结构相同 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 映射配置文件的操作配置（select） id 属性的取值必须是dao接口的方法名 无需再写dao的实现类 --&gt; &lt;select id=\"findAll\" resultType=\"com.dzu.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类 1234567891011121314151617181920212223public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 //SqlSessionFactoryBuilder一旦创建了SqlSessionFactory，就不再需要他了 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，默认单例模式 SqlSessionFactory factory = builder.build(in); //3.使用工厂生产一个SqlSession对象 //每次收到http请求，就可以打开一个SqlSession。所以关闭操作很重要 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 CustomerMapper csm = session.getMapper(CustomerMapper.class); //5，使用代理对象执行方法 List&lt;User&gt; users = csm.findAll(); for (User user : users) System.out.println(user); //6.释放资源 session.close(); in.close(); &#125;&#125; 4.可能出现问题说明：Maven静态资源过滤问题 ​ Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource CustomerMapper.xml 123456789101112131415161718&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 可能遇到的问题 配置文件没有注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 5.CRUD namespace namespace中的包名要和Dao/Mapper接口的包名一致！ select 查询语句 id：就是对应的namespace中的方法名； resultType： Sql语句执行的返回值！ parameterType: 参数类型 多个参数用Map 或者注解 编写接口 编写对应的mapper中的sql语句 测试 注意增删改commit的提交！！！ 标签不要匹配错 程序配置文件必须符合规范 资源路径 resource绑定mapper使用路径 6.配置解析1.核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 元素类型为 “configuration” 的内容必须匹配 “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”。 2.环境配置（environments）Mybatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，单每个SqlSessionFactory实例只能选择一种环境 Mybatis默认的事务管理器就是JDBC， 连接池 ： POOLED 3.属性（properties）我们可以通过properties属性来引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性。【db.properties】 编写一个配置文件 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisusername=rootpassword=root 在核心配置文件进行引入 12345&lt;!--引入外部配置文件 优先使用--&gt;&lt;properties resource=\"db.properties\"&gt; &lt;property name=\"u\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"p\" value=\"root\"&gt;&lt;/property&gt;&lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置的！ 4.类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 扫描实体类的包，他的默认别名就为这个类的 类名 首字母小写 12345&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;!--&lt;typeAlias type=\"com.dzu.pojo.User\" alias=\"User\"&gt;&lt;/typeAlias&gt;--&gt; &lt;package name=\"com.dzu.pojo\" &gt;&lt;/package&gt;&lt;/typeAliases&gt; 实体类少的时候 用第一种 实体类多 第二种 第一种可以DIY起名 第二种不行，如果非要改，在实体类上增加注释 12@Alias(\"user\")public class User &#123; 5.设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 6.其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） mybatis-generator-core mybatis-plus 通用mapper 7.映射器（mappers）MapperRegistry：注册绑定我们的Mapper文件 1.[推荐使用，大多数] 1234&lt;!--每一个Mapper。xml都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 2.使用class文件绑定注册 1234&lt;mappers&gt; &lt;!--&lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;--&gt; &lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 注意点 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 3.使用扫描包进行注入绑定 12345&lt;mappers&gt; &lt;!--&lt;mapper resource=\"com/dzu/mapper/UserMapper.xml\"/&gt;--&gt; &lt;!--&lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;--&gt; &lt;package name=\"com.dzu.mapper\"&gt;&lt;/package&gt;&lt;/mappers&gt; 注意点 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 练习 将数据库配置文件外部引入 实体类别名 保证UserMapper接口和UserMapper.xml保持一致，并放在同一个包下 8.生命周期和作用域生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBulider 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory 说白了就是可以想象为：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 SqlSessionFactory 的最佳作用域是应用作用域 最简单的就是使用单例模式或者静态单例模式。 SqlSession 连接到连接池的一个请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后赶紧关闭，否则资源被占用 SqlSessionFactory可以open多个SqlSession，SqlSession也能get多个Mapper 每一个Mapper，就代表一个具体的业务！ 7.解决属性名和字段名不一致的问题解决方案 起别名 123&lt;select id=\"findUserById\" resultType=\"user\" parameterType=\"int\"&gt; select id,name,pwd as password from user where id = #&#123;id&#125;;&lt;/select&gt; resultMap结果集映射 123456789101112&lt;!--结果集映射--&gt;&lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!--column数据库中的字段 property实体类中的属性--&gt; &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;result column=\"pwd\" property=\"password\"&gt;&lt;/result&gt;&lt;/resultMap&gt; &lt;select id=\"findUserById\" resultMap=\"UserMap\" parameterType=\"int\"&gt; select * from user where id = #&#123;id&#125;;&lt;/select&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们 如果这个世界总是这么简单就好了。 8.日志1.日志工厂如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手。 SLF4J LOG4J【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在mybatis中具体使用哪一个日志实现，在设置中设定 STDOUT_LOGGING 标准日志输出 在Mybatis核心配置文件中，配置我们的日志 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; 2.Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等； 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 导入log4j的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties文件的配置 简单使用 在要使用Log4j的类中，导入包import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(Test.class); 日志级别 123logger.info(\"info\");logger.debug(\"debug\");logger.error(\"error\"); 9.分页1.为什么要分页 减少数据的处理量 2.使用Limit分页1语法：select * from mybatis.user limit startIndex,pageSize; 使用Mybatis实现分页，核心SQL 1.接口 1List&lt;User&gt; getUserLimit(Map&lt;String,Integer&gt; map); 2.Mapper.xml 123&lt;select id=\"getUserLimit\" parameterType=\"map\" resultType=\"User\"&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;/select&gt; 3.测试 12345678910SqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);HashMap&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();map.put(\"startIndex\",0);map.put(\"pageSize\",1);List&lt;User&gt; users = mapper.getUserLimit(map);for (User user : users) &#123; System.out.println(user);&#125;sqlSession.close(); 10.使用注解开发面向接口编程； 解耦，可扩展，提高复用，分层开发 1.注解在接口上实现 12@Select(\"select * from user\")List&lt;User&gt; getUsers(); 2.需要在核心配置文件中绑定接口 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=\"com.dzu.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 本质：反射机制实现 底层：动态代理 关于@param()注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个类型的话，可以忽略，建议加上 我们在SQL中引用的就是我们这里的@Param()中设定的属性名 11.Mybatis执行流程Resources获取加载全局配置文件 实例化SqlsessionFactoryBuilder构造器 解析文件流XMLConfigBuilder Configuration所有的配置信息 SqlSessionFactory实例化 transactional事务管理 创建executor执行器 创建SqlSession 实现CRUD false则回滚 是否执行成功 false则回滚 提交事务 关闭 12.多对一处理测试环境搭建12345678910111213141516171819202122create table teacher( id int(10) not null, name varchar(30) default null, primary key (id)) engine=innodb default charset=utf8insert into teacher(id,name) values (1,'赵老师');create table student( id int(10) not null, name varchar(30) default null, tid int(10) default null, primary key (id), key fktid (tid), constraint fktid foreign key (tid) references teacher(id))engine=innodb default charset=utf8insert into student(id,name,tid) values (1,'小明',1);insert into student(id,name,tid) values (2,'小等',1);insert into student(id,name,tid) values (3,'小的',1);insert into student(id,name,tid) values (4,'小给',1);insert into student(id,name,tid) values (5,'小和',1); 导入lombok 新建实体类Teacher,Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件 测试查询能否成功 按照查询嵌套处理12345678910111213141516&lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from student;&lt;/select&gt;&lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"name\"&gt;&lt;/result&gt; &lt;!--复杂的属性，我们需要单独处理--&gt; &lt;!--对象： association 集合： collection --&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from teacher where id = #&#123;id&#125;;&lt;/select&gt; 按照结果嵌套处理12345678910111213&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid,s.name sname,t.id tid ,t.name tname from student s ,teacher t where s.tid = t.id ; &lt;/select&gt; &lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"sname\"&gt;&lt;/result&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"id\" column=\"tid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"tname\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 13.一对多处理比如：一个老师拥有多个学生 对于老师而言，就是一对多的关系。 搭建环境 和刚才一样 实体类 123456@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 12345678@Datapublic class Teacher &#123; private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students;&#125; 按照结果嵌套处理 12345678910111213141516171819202122&lt;!--按照结果嵌套查询--&gt;&lt;select id=\"getTeacher\" resultMap=\"TeacherStudent\"&gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=\"TeacherStudent\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"tid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"tname\"&gt;&lt;/result&gt; &lt;!--复杂的属性，我们需要单独处理--&gt; &lt;!--对象： association 集合： collection javaType 指定属性的类型！ 集合中的泛型信息 我们使用ofType获取 --&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"sname\"&gt;&lt;/result&gt; &lt;result property=\"tid\" column=\"tid\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理 12345678910111213&lt;select id=\"getTeacher2\" resultMap=\"TeacherStudent2\"&gt; select * from teacher where id =#&#123;tid&#125;;&lt;/select&gt;&lt;resultMap id=\"TeacherStudent2\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"name\" column=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentsByTeacherID\" column=\"id\"&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"getStudentsByTeacherID\" resultType=\"Student\"&gt; select * from student where tid = #&#123;tid&#125;&lt;/select&gt; 小结 关联- association【多对一】 集合- collection javaType &amp; ofType 1.javaType 用来指定实体类中属性的类型 2.ofType 用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！ 注意点保证SQL的可读性，尽量保证通俗易懂！注意一对多和多对一中，属性名和字段的问题！如果问题不好排查错误，可以使用日志，建议Log4j 面试高频Mysql引擎innoDB底层原理索引索引优化！ 14.动态SQL什么是动态sql： 动态sql就是根据不同的条件生成不同的sql语句 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach 搭建环境1234567create table blog( id varchar(50) not null comment '博客id', title varchar(100) not null comment '博客标题', author varchar(30) not null comment '博客作者', create_time datetime not null comment '创建时间', views int(30) not null comment '浏览量')engine=innodb default charset=utf8; 创建一个基础工程 导包 编写配置文件 编写实体类 12345678@Datapublic class Blog &#123; private int id; private String title; private String author; private Date createTime; private int views;&#125; 编写实体类对应Mapper接口和Mapper.xml文件 IF123456789&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog where 1=1 &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; trim (where, set)set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 1234567891011&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 123456789101112&lt;update id=\"updateBlog\" parameterType=\"map\"&gt; update blog &lt;set&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; author =#&#123;author&#125; &lt;/if&gt; where id = #&#123;id&#125; &lt;/set&gt;&lt;/update&gt; choose (when, otherwise)123456789101112131415161718传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就 按 otherwise 里面的查找&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title != null\"&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views =#&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 所谓的动态SQL, 本只还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 SQL片段有的时候 我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 12345678&lt;sql id=\"if-title-author\"&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author =#&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 在需要使用的地方使用include标签引用即可 123456&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from mybatis.blog &lt;where&gt; &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; 注意事项 最好基于单表来定义SQL片段 sql标签内 不要存在where标签 foreach12345678910官网：&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 123456789&lt;!--我们传递一个万能Map，里面存在一个集合--&gt;&lt;select id=\"queryBlogForeach\" resultType=\"Blog\" parameterType=\"map\"&gt; select * from blog &lt;where&gt; &lt;foreach collection=\"mid\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mybatis中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可 15.缓存Mybatis缓存 MyBatis包含- 个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效 MyBatis系统中默认定义了两级缓存: 一级缓存和二级缓存 1、默认情况下，只有一级缓存开启。(SqlSession级别的缓存, 也称为本地缓存) 2、二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 3、为了提高扩展性, MyBatis定义了缓存接口Cache.我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存：SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤 开启日志 测试再一个Session、中查询两次相同的记录 查看日志输出 12345678910111213Opening JDBC ConnectionCreated connection 238157928.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)===============User(id=1, name=zd, pwd=123)true &gt;&gt;&gt; user == user2Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@e320068]Returned connection 238157928 to pool. 缓存失效的情况 查询不同的东西 曾删改操作，可能会改变原来的数据，所以必定会刷新缓存 123456789101112131415161718192021Opening JDBC ConnectionCreated connection 32863545.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)==&gt; Preparing: update mybatis.user set name=?,pwd=? where id = ? ==&gt; Parameters: aaa(String), nnn(String), 2(Integer)&lt;== Updates: 1=================&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)false 》》》 缓存刷新 两个User不相等Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1f57539]Returned connection 32863545 to pool. 查询不同的Mapper.xml 手动清理缓存：SqlSession.clearCache(); 123456789101112131415161718Opening JDBC ConnectionCreated connection 32863545.==&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)=================&gt; Preparing: select * from mybatis.user where id = ? ==&gt; Parameters: 1(Integer)&lt;== Columns: id, name, pwd&lt;== Row: 1, zd, 123&lt;== Total: 1User(id=1, name=zd, pwd=123)falseClosing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1f57539]Returned connection 32863545 to pool. 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个Map 二级缓存●二级缓存也叫全局缓存, -级缓存作用域太低了,所以诞生了二级缓存 ●基于namespace级别的缓存，-个名称空间，对应一个二 级缓存; ●工作机制 一个会话查询一条数据,这个数据就会被放在当前会话的- -级缓存中; 如果当前会话关闭了，这个会话对应的一-级缓存就没了;但是我们想要的是,会话关闭了，一级缓存中的数据被保存到二级缓存中; 新的会话查询信息，就可以从二级缓存中获取内容; 不同的mapper查出的数据会放在自己对应的缓存(map) 中； 步骤 开启全局缓存 12&lt;!--显示的开启全局缓存--&gt; &lt;setting name=\"cacheEnable\" value=\"true\"&gt;&lt;/setting&gt; 在要使用二级缓存Mapper中开启 12&lt;!--在当前Mapper.xml中，使用二级缓存--&gt;&lt;cache&#x2F;&gt; 也可以自定义参数 123456&lt;!--在当前Mapper.xml中，使用二级缓存--&gt;&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 测试1.问题： 我们需要将实体类序列化！否者就会报错 1Caused by: java.io.NotSerializableException: com.dzu.pojo.User 小结 只要开启了二级缓存，在同一个Mapper下就有效； 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓存中； 缓存原理用户首先从二级缓存中查找数据，如果没有查到，就去一级缓存查找，还没有就去数据库中查找。 然后将在数据库中查找的数据放到一级缓存中，供当前SqlSession使用， 当关闭SqlSesion，一级缓存的内容会加入到二级缓存中，此时 二级缓存为整个Mapper服务 自定义缓存-ehcacheEhcache是一种广泛使用的开源Java分布式缓存，主要面向通用缓存 要在程序中导包 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"如何搭建Hexo简单教程","slug":"我的第一篇博客文章","date":"2020-04-10T03:23:21.000Z","updated":"2020-04-10T14:16:25.646Z","comments":true,"path":"2020/04/10/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/04/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"##如何搭建Hexo 简单搭建Hexo","text":"##如何搭建Hexo 简单搭建Hexo 安装nods.js 进入cmd，npm外网太慢，用taobaonpm install -g cnpm –registry=https://registry.npm.taobao.org 安装hexocnpm install -g hexo-cli 初始化hexohexo init 启动hexo s 创建新的博客 hexo n ##将hexo发布到github 安装 gitcnpm install –save hexo-deployer-git 修改_config.yml文件 type: git repo: https://github.com/zd1181803971/zd1181803971.github.io.git branch: master 部署hexo d 重新生成 发布 hexo g hexo s hexo d ##参考文献 https://www.bilibili.com/video/BV1Yb411a7ty","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-10T03:19:45.303Z","updated":"2020-04-10T14:16:43.236Z","comments":true,"path":"2020/04/10/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}